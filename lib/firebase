import { getAuth } from "firebase/auth"; // âœ… Ajout de getAuth
import { initializeApp } from "firebase/app";
import { getFirestore, collection, getDocs, doc, setDoc, getDoc } from "firebase/firestore";

// ðŸ“Œ VÃ©rification des variables dâ€™environnement Firebase
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};


// ðŸ”¥ Initialisation Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app)
const db = getFirestore(app);

/**
 * Enregistre une range dans Firestore
 * @param {string} rangeId - Identifiant unique de la range
 * @param {string} context - Contexte du jeu (ex: MTT, Cash Game, etc.)
 * @param {string} rangeName - Nom de la range
 * @param {string | number} blinds - Valeur des blinds (ex: 20, "20 < BB < 80", "BB < 60")
 * @param {number} numSeats - Nombre de siÃ¨ges Ã  la table (ex: 6, 8, 9)
 * @param {string} heroPosition - Position du HÃ©ros Ã  la table (ex: "CO", "BTN")
 * @param {string} spot - Type de spot jouÃ© (ex: "Open", "3bet", "Overcall & Squeeze")
 * @param {string} villainPosition - Position du Villain si applicable, sinon vide
 * @param {object} handColors - Actions prises pour chaque main sous forme { "AA": "raise", "AKs": "call" }
 */
export async function saveRangeToFirebase(rangeId, context, rangeName, blinds, numSeats, heroPosition, spot, villainPosition, handColors) {
  try {
    const rangeRef = doc(db, "ranges", rangeId);

    // âœ… Extraction des valeurs min et max pour le filtrage Firestore
    let blindsMin = null, blindsMax = null;
    let sanitizedBlinds = blinds.trim();

    if (/^\d+$/.test(sanitizedBlinds)) {
      // âœ… Si c'est un nombre, le stocker en tant que `number`
      const num = parseInt(sanitizedBlinds, 10);
      if (num >= 5 && num <= 100) {
        blindsMin = num;
        blindsMax = num;
      } else {
        console.warn("ðŸš¨ Valeur des blinds invalide, doit Ãªtre entre 5 et 100.");
        return;
      }
    } else if (/^\d+\s*<\s*BB\s*<\s*\d+$/.test(sanitizedBlinds)) {
      // âœ… Si c'est une fourchette (ex: "20 < BB < 80")
      const matches = sanitizedBlinds.match(/\d+/g);
      blindsMin = parseInt(matches[0], 10);
      blindsMax = parseInt(matches[1], 10);
    } else if (/^BB\s*<\s*\d+$/.test(sanitizedBlinds)) {
      // âœ… Si c'est un maximum (ex: "BB < 60")
      blindsMax = parseInt(sanitizedBlinds.match(/\d+/)[0], 10);
    } else if (/^\d+\s*<\s*BB$/.test(sanitizedBlinds)) {
      // âœ… Si c'est un minimum (ex: "30 < BB")
      blindsMin = parseInt(sanitizedBlinds.match(/\d+/)[0], 10);
    } else {
      console.warn("ðŸš¨ Format invalide. Utilisez un nombre (20), une fourchette (20 < BB < 80), un max (BB < 60) ou un min (30 < BB).");
      return;
    }

    // âœ… PrÃ©pare les donnÃ©es Ã  enregistrer
    const rangeData = {
      context: context || "MTT", // âœ… MTT par dÃ©faut
      rangeName: rangeName || "Range",
      blindsRaw: sanitizedBlinds, // âœ… Garde l'entrÃ©e originale
      blindsMin, // âœ… Valeur min pour le filtrage
      blindsMax, // âœ… Valeur max pour le filtrage
      numSeats: numSeats || 6, // âœ… Par dÃ©faut 6 joueurs
      heroPosition: heroPosition || "CO", // âœ… Valeur par dÃ©faut
      spot: spot || "Open",
      villainPosition: spot === "Open" ? "Aucun": villainPosition,
      handColors: handColors || {},
      timestamp: new Date().toISOString(),
    };

    await setDoc(rangeRef, rangeData);

    console.log("âœ… Range enregistrÃ©e avec succÃ¨s :", rangeId);
  } catch (error) {
    console.error("ðŸš¨ Erreur lors de l'enregistrement de la range :", error);
  }
}

/**
 * ðŸ“Œ RÃ©cupÃ¨re une range depuis Firestore
 * @param {string} rangeId - Identifiant unique de la range
 * @returns {object|null} - Les donnÃ©es de la range ou null si elle n'existe pas
 */
export async function getRangeData(rangeId) {
  try {
    const rangeRef = doc(db, "ranges", rangeId);
    const docSnap = await getDoc(rangeRef);

    if (docSnap.exists()) {
      console.log("ðŸ“Œ DonnÃ©es rÃ©cupÃ©rÃ©es depuis Firebase :", docSnap.data());
      return docSnap.data();
    } else {
      console.log("âŒ Aucune range trouvÃ©e pour l'ID :", rangeId);
      return null;
    }
  } catch (error) {
    console.error("ðŸš¨ Erreur lors de la rÃ©cupÃ©ration de la range :", error);
    return null;
  }
}

/**
 * ðŸ“Œ RÃ©cupÃ¨re toutes les ranges stockÃ©es dans Firebase
 * @returns {Array} - Tableau des ranges { id, rangeName }
 */
export async function getAllRanges() {
  try {
    const querySnapshot = await getDocs(collection(db, "ranges"));
    return querySnapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
  } catch (error) {
    console.error("ðŸš¨ Erreur lors de la rÃ©cupÃ©ration des ranges :", error);
    return [];
  }
}


export { auth,db };
